
package main


import (
	. "fmt"
	"net/http"
//	"time"
	"github.com/go-nsq"
	"log"
	"sync"
	"encoding/json"
	"bytes"
	"io/ioutil"
)


// http://tleyden.github.io/blog/2014/11/12/an-example-of-using-nsq-from-go/

type Infra struct {
	Cloud		string    `json:"cloud"`
	Cloudtype	string    `json:"cloudtype"`
	Zone		string	  `json:"zone"`
}

func producer() {
  config := nsq.NewConfig()
  w, _ := nsq.NewProducer("127.0.0.1:4150", config)
  err := w.Publish("write_test", []byte("test"))
  if err != nil {
     log.Panic("Could not connect")
  }
  w.Stop()

}



// Generated by curl-to-Go: https://mholt.github.io/curl-to-go

//type Payload struct {
//	Auth struct {
//		Identity struct {
//			Methods  []string `json:"methods"`
//			Password struct {
//				User struct {
//					Name   string `json:"name"`
//					Domain struct {
//						ID string `json:"id"`
//					} `json:"domain"`
//					Password string `json:"password"`
//				} `json:"user"`
//			} `json:"password"`
//		} `json:"identity"`
//	} `json:"auth"`
//}

type Domain struct {
	ID string `json:"id"`
} 

type User struct {
	Name   string `json:"name"`
	Domain `json:"domain"`
	Password string `json:"password"`
} 

type Password struct {
	User `json:"user"`
} 
 
type Identity struct {
	Methods  [1]string `json:"methods"`
	Password `json:"password"`
} 

type Auth struct {
	Identity `json:"identity"`
} 

type Payload struct {
	Auth `json:"auth"`
}

func MessageHandler(message *nsq.Message) error {
	var in Infra
	err := json.Unmarshal(message.Body, &in)
	if err != nil {
		Printf("Error In JSON Decoder....\n")
    }
	Printf("zone value: %s: cloud value: %s: cloud type: %s \n ", in.Zone, in.Cloud, in.Cloudtype)

	url := "http://10.128.0.3:5000/v3/auth/tokens" 
	var data Payload

	data.Auth.Identity.Methods[0] = "password"
	data.Auth.Identity.Password.User.Name = "demo"
	data.Auth.Identity.Password.User.Domain.ID = "default"
	data.Auth.Identity.Password.User.Password = "stack123"

	payload, err := json.Marshal(data)
	Printf(" Json payload data\n %s", payload)
	if err != nil {
	// handle err
		Printf(" Json Marshalling Auth String Error\n %s", err)
	}
	body := bytes.NewReader(payload)
	req, err := http.NewRequest("POST", url, body)
	if err != nil {
	// handle err
		Printf(" http new request Error %s\n ", err)
	}
	req.Header.Set("Content-Type", "application/json")
	resp, err := http.DefaultClient.Do(req)
	if err != nil {
	// handle err
		Printf(" http Do request Error %s\n ", err)
	}
	defer resp.Body.Close()
	response, _ := ioutil.ReadAll(resp.Body)
	var prettyJSON bytes.Buffer
	err = json.Indent(&prettyJSON, response, "", "\t")
	if err != nil {
	// handle err
		Printf(" Json Indent Error %s\n ", err)
	}
	res := string(prettyJSON.Bytes())
	Printf("Auth Response From Openstack: %s \n", res)
  	config := nsq.NewConfig()
  	prod, _ := nsq.NewProducer("127.0.0.1:4150", config)
	msg := []byte(res)
  	err = prod.Publish("infra_response", msg)
	return nil
}

func consumer() {
	hdlr :=  MessageHandler 
	wg := &sync.WaitGroup{}
	wg.Add(10)
	config := nsq.NewConfig()
	q, _ := nsq.NewConsumer("infra_request", "ch", config)
	q.AddHandler(nsq.HandlerFunc(hdlr))
	wg.Done()
  	err := q.ConnectToNSQD("127.0.0.1:4150")
  	if err != nil {
      log.Panic("Could not connect")
  	}
  	wg.Wait()
}


func main() {
	//producer()
	consumer()
}
